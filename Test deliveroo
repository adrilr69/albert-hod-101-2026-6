-- Méthodologie :
-- 1) Taguer une période : start/end des séquences de livraisons gratuites (par client)
-- 2) Compter le volume de commandes gratuites dans cette période
-- 3) Dire si c'est un abonnement potentiel (>= threshold)
-- 4) Sortir les 3 colonnes demandées + start/end si abonnement

CREATE OR REPLACE TABLE `head-of-data-2.group_6.enriched_synthetic_deliveroo_plus_dataset` AS
WITH
  -- Paramètre : facile à changer (3 -> 20)
  params AS (
    SELECT 3 AS threshold
  ),

  -- STEP 0 : dataset de base (colonnes utiles uniquement)
  base AS (
    SELECT
      id_customer_synth,
      order_datetime_synth,
      is_free_delivery
    FROM `head-of-data-2.assignment_data.synthetic_deliveroo_plus_dataset`
  ),

  -- STEP 1 : on crée un identifiant de "période" (period_id)
  -- Une nouvelle période commence à chaque livraison payante (is_free_delivery = 0).
  -- Donc toutes les commandes entre deux payantes appartiennent au même period_id.
  periods AS (
    SELECT
      *,
      SUM(CASE WHEN is_free_delivery = 0 THEN 1 ELSE 0 END) OVER (
        PARTITION BY id_customer_synth
        ORDER BY order_datetime_synth
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
      ) AS period_id
    FROM base
  ),

  -- STEP 2 : d'abord taguer les dates de période (start/end)
  -- Ici, on cherche : la 1ère commande gratuite et la dernière commande gratuite du period_id.
  tagged_dates AS (
    SELECT
      *,
      MIN(IF(is_free_delivery = 1, order_datetime_synth, NULL)) OVER (
        PARTITION BY id_customer_synth, period_id
      ) AS potential_start_dt,
      MAX(IF(is_free_delivery = 1, order_datetime_synth, NULL)) OVER (
        PARTITION BY id_customer_synth, period_id
      ) AS potential_end_dt
    FROM periods
  ),

  -- STEP 3 : ensuite, compter le volume dans la période
  -- On compte le nombre de commandes gratuites comprises dans ce period_id
  -- (c'est ce qu'on compare au threshold).
  counted_orders AS (
    SELECT
      *,
      COUNTIF(is_free_delivery = 1) OVER (
        PARTITION BY id_customer_synth, period_id
      ) AS nb_free_orders_in_period
    FROM tagged_dates
  )

-- STEP 4 : décider si c'est un abonnement + sortir les colonnes finales
SELECT
  id_customer_synth,
  order_datetime_synth,
  is_free_delivery,

  -- Abonnement si :
  -- (1) la commande est gratuite
  -- (2) et la période contient au moins threshold commandes gratuites
  CASE
    WHEN is_free_delivery = 1
     AND nb_free_orders_in_period >= (SELECT threshold FROM params)
    THEN 1 ELSE 0
  END AS is_order_made_during_subscription,

  -- Si abonnement : start/end = celles qu'on a taguées (potential_start_dt / potential_end_dt)
  CASE
    WHEN is_free_delivery = 1
     AND nb_free_orders_in_period >= (SELECT threshold FROM params)
    THEN potential_start_dt ELSE NULL
  END AS current_subscription_start_datetime,

  CASE
    WHEN is_free_delivery = 1
     AND nb_free_orders_in_period >= (SELECT threshold FROM params)
    THEN potential_end_dt ELSE NULL
  END AS current_subscription_end_datetime

FROM counted_orders;

